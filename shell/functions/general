# ----------------------------------------------------
#
#   Functions - General
#   -> Specified tasks
#
# ----------------------------------------------------

# ----------------------------------------------------
#   Dependencies
# ----------------------------------------------------

# ----- Path ----- #

# Echo the working directory without the full path
function working_directory() {
  printf $(basename "$(pwd)")
}

# ----- Curl ----- #

function get_curl_response() {
  curl -s -I $1 | grep HTTP/1.1
}

# ----- Git ----- #

# Show the Git branch if it's a repo
function branch_if_repo() {
  if [ "$(which git)" ] && [[ -d ./.git ]]; then
    # Working directory clean
    if (( $(git status --porcelain | wc -l | tr -d "[:space:]") == 0 )); then
      printf "$(tput setaf $GREEN)($(parse_git_branch))"

    # Working directory dirty
    else

      # Untracked files
      if [[ $(git status --porcelain | grep -c "^ \?\?") -gt 0 ]]; then
        printf "$(tput setaf $RED)($(parse_git_branch))"

      # Modified/removed files
      else
        printf "$(tput setaf $YELLOW)($(parse_git_branch))"
      fi
    fi
  fi
}

# Get the current Git branch
function parse_git_branch() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  printf "${ref#refs/heads/}"
}

# ----------------------------------------------------
#   Commands
# ----------------------------------------------------

# ----- mkcd ----- #
# Make directory and navigate to it
#
# $1 - Directory name
#
# Usage: `mkcd directory-name`

function mkcd() {
  mkdir -p "$1"
  cd "$1"
}

# ----- dlz ----- #
# Extract external ZIP archive
#
# $1 - ZIP file URL
#
# Usage: `dlz https://github.com/mvcss/mvcss/archive/master.zip`

function dlz() {
  # -L must come before -o to follow redirection
  curl -s -L -o .tempzip "$1"
  unzip -q .tempzip
  rm .tempzip
}

# ----- GZIP Size ----- #
# Print file size after GZIP compression
#
# $1 - File
#
# Usage: `gzip_size application.css`

function gzip_size() {
  gzip -fk "$1" \
  && ls -hl "$1".gz | awk '{ printf $5 }' && printf ' ' \
  && ls -l "$1".gz | awk '{ print $5 }' \
  && rm "$1".gz
}

# ----- Tag ----- #
# Automatically set a git tag based on Semantic Versioning keyword
# (via @drewbarontini)
#
# $1 - 'major', 'minor', 'patch'
#
# Usage: `git_tag major`

function git_tag() {
  local tag=$(git describe --abbrev=0 --tags 2>/dev/null)
  local prefix=$(echo $tag | grep -o --color=never "[A-z]\+")
  local major=$(echo $tag | cut -d '.' -f1 | grep -o --color=never "[0-9]")
  local minor=$(echo $tag | cut -d '.' -f2)
  local patch=$(echo $tag | cut -d '.' -f3)

  case "$1" in
    'major')
      local nmajor=$(($major+1))
      local version="$nmajor.0.0"
      ;;
    'minor')
      local nminor=$(($minor+1))
      local version="$major.$nminor.0"
      ;;
    'patch')
      local npatch=$(($patch+1))
      local version="$major.$minor.$npatch"
      ;;
    *)
      echo "Automatically set a git tag based on Semantic Versioning keyword"
      echo
      echo "Usage: git_tag <major|minor|patch>"
      echo
      echo "Example:"
      echo "  git_tag major"
      echo
      echo "If this is your first tag, use 'git tag' to set up your first one."
  esac

  if [[ "$version" ]]
  then
    git tag -a "$prefix$version" -m "Version $version"
    echo "$prefix$version created!"
  fi
}
